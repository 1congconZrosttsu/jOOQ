/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Other licenses:
 * -----------------------------------------------------------------------------
 * Commercial licenses for this work are available. These replace the above
 * ASL 2.0 and offer limited warranties, support, maintenance, and commercial
 * database integrations.
 *
 * For more information, please visit: http://www.jooq.org/licenses
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

package org.jooq;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.Spliterator;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
// ...
import java.util.function.Consumer;
import java.util.stream.Collector;
import java.util.stream.Stream;

import javax.sql.DataSource;

import org.jooq.conf.Settings;
import org.jooq.exception.DataAccessException;
import org.jooq.exception.DataTypeException;
import org.jooq.exception.InvalidResultException;
import org.jooq.exception.MappingException;
import org.jooq.exception.NoDataFoundException;
import org.jooq.exception.TooManyRowsException;
import org.jooq.impl.DefaultRecordMapper;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * A query that can return results.
 * <p>
 * jOOQ distinguishes between ordinary {@link Query} types, such as
 * {@link Insert}, {@link Update}, {@link Delete}, and any {@link DDLQuery},
 * which are meant to produce side effects in a database, and the
 * {@link ResultQuery}, which is meant to produce a {@link Result} through
 * various means.
 * <p>
 * The most common way to create a result is by calling {@link #fetch()}, or by
 * using the query's {@link #iterator()} method in a foreach loop:
 * <p>
 * <code><pre>
 * Result&lt;TRecord> result = ctx.select(T.A, T.B).from(T).fetch();
 *
 * for (TRecord record : ctx.select(T.A, T.B).from(T)) {
 *   // ...
 * }
 * </pre></code>
 * <p>
 * Most approaches to fetching results in {@link ResultQuery} (including the
 * above), fetch the entire JDBC {@link ResultSet} eagerly into memory, which
 * allows for closing the underlying JDBC resources as quickly as possible. Such
 * operations are not resourceful, i.e. users do not need to worry about closing
 * any resources.
 * <p>
 * There are, however, some ways of fetching results lazily, and thus in a
 * resourceful way. These include:
 * <ul>
 * <li>{@link ResultQuery#fetchLazy()} and related methods, which produce a
 * {@link Cursor} for imperative style consumption of resulting records.</li>
 * <li>{@link ResultQuery#fetchStream()} and related methods, which produce a
 * Java {@link Stream} for functional style consumption of resulting
 * records.</li>
 * </ul>
 * <p>
 * In both cases, it is recommended to explicitly close the underlying resources
 * (i.e. JDBC {@link ResultSet}) using <code>try-with-resources</code>:
 * <p>
 * <code><pre>
 * try (Cursor&lt;TRecord> cursor = ctx.select(T.A, T.B).from(T).fetchLazy()) {
 *   for (;;) {
 *     TRecord record = cursor.fetchNext();
 *     if (record == null)
 *       break;
 *
 *     // ...
 *   }
 * }
 *
 * try (Stream&lt;TRecord> stream = ctx.select(T.A, T.B).from(T).fetchStream()) {
 *   stream.forEach(record -> {
 *     // ...
 *   });
 * }
 * </pre></code>
 * <p>
 * While most instances of {@link ResultQuery} implement {@link Select}, there
 * also exist other types of {@link ResultQuery} constructed e.g. from plain SQL
 * APIs, such as {@link DSLContext#resultQuery(String)}.
 * <p>
 *
 * @author Lukas Eder
 */
public interface ResultQuery<R extends Record>
extends
    Query
  , Fetchable<R>
, org.reactivestreams.Publisher<R>

{

    /**
     * Return the result generated by a previous call to execute().
     *
     * @return The result or <code>null</code> if no call to execute() was done
     *         previously.
     */
    @Nullable
    Result<R> getResult();

    /**
     * The record type produced by this query.
     */
    @NotNull
    Class<? extends R> getRecordType();

    @NotNull
    @Override
    ResultQuery<R> bind(String param, Object value) throws IllegalArgumentException, DataTypeException;

    @NotNull
    @Override
    ResultQuery<R> bind(int index, Object value) throws IllegalArgumentException, DataTypeException;

    // ------------------------------------------------------------------------
    // JDBC methods
    // ------------------------------------------------------------------------

    @NotNull
    @Override
    ResultQuery<R> poolable(boolean poolable);

    @NotNull
    @Override
    ResultQuery<R> queryTimeout(int timeout);

    @NotNull
    @Override
    ResultQuery<R> keepStatement(boolean keepStatement);

    /**
     * Specify the maximum number of rows returned by the underlying
     * {@link Statement}.
     * <p>
     * This is not the same as setting a <code>LIMIT .. OFFSET</code> clause
     * onto the statement, where the result set is restricted within the
     * database.
     *
     * @see Statement#setMaxRows(int)
     */
    @NotNull
    ResultQuery<R> maxRows(int rows);

    /**
     * Specify the fetch size of the underlying {@link Statement}.
     * <p>
     * Regardless of this setting, {@link #fetchLazy()} is the only way in jOOQ
     * not to fetch all data in memory. However, you may influence how your JDBC
     * driver interacts with your database through specifying a fetch size.
     * <p>
     * Dialect-specific remarks:
     * <ul>
     * <li>MySQL uses {@link Integer#MIN_VALUE} as an indicator to fetch
     * resulting rows row-by-row in conjunction with
     * {@link ResultSet#TYPE_FORWARD_ONLY} (set in {@link #resultSetType(int)})
     * and {@link ResultSet#CONCUR_READ_ONLY} (set in
     * {@link #resultSetConcurrency(int)}). See <a href=
     * "http://dev.mysql.com/doc/connector-j/en/connector-j-reference-implementation-notes.html">
     * this page here</a> for details.</li>
     * <li>PostgreSQL does not like fetch sizes being combined with
     * <code>{@link Connection#getAutoCommit()} == true</code>. For more
     * information, see <a href=
     * "http://jdbc.postgresql.org/documentation/head/query.html#query-with-cursor"
     * >this page here</a></li>
     * </ul>
     *
     * @see Statement#setFetchSize(int)
     */
    @NotNull
    ResultQuery<R> fetchSize(int rows);

    /**
     * Specify the <code>ResultSet</code> concurrency of <code>ResultSet</code>
     * objects created by jOOQ.
     * <p>
     * This will affect the way you may perceive <code>ResultSet</code> objects
     * obtained from any of these methods:
     * <ul>
     * <li>{@link ResultQuery#fetchResultSet()}</li>
     * <li>{@link Cursor#resultSet()}</li>
     * <li>{@link ExecuteContext#resultSet()}</li>
     * </ul>
     *
     * @see Statement#getResultSetConcurrency()
     */
    @NotNull
    ResultQuery<R> resultSetConcurrency(int resultSetConcurrency);

    /**
     * Specify the <code>ResultSet</code> type of <code>ResultSet</code>
     * objects created by jOOQ.
     * <p>
     * This will affect the way you may perceive <code>ResultSet</code> objects
     * obtained from any of these methods:
     * <ul>
     * <li>{@link ResultQuery#fetchResultSet()}</li>
     * <li>{@link Cursor#resultSet()}</li>
     * <li>{@link ExecuteContext#resultSet()}</li>
     * </ul>
     *
     * @see Statement#getResultSetType()
     */
    @NotNull
    ResultQuery<R> resultSetType(int resultSetType);

    /**
     * Specify the <code>ResultSet</code> holdability of <code>ResultSet</code>
     * objects created by jOOQ.
     * <p>
     * This will affect the way you may perceive <code>ResultSet</code> objects
     * obtained from any of these methods:
     * <ul>
     * <li>{@link ResultQuery#fetchResultSet()}</li>
     * <li>{@link Cursor#resultSet()}</li>
     * <li>{@link ExecuteContext#resultSet()}</li>
     * </ul>
     *
     * @see Statement#getResultSetHoldability()
     */
    @NotNull
    ResultQuery<R> resultSetHoldability(int resultSetHoldability);

    /**
     * Specify a set of fields whose values should be interned.
     * <p>
     * Unlike {@link Result}'s <code>intern()</code> methods, this already
     * interns values right after fetching them from a JDBC result set. See
     * {@link Result#intern(int...)} for more details.
     *
     * @param fields The fields whose values should be interned
     * @return The same result query
     * @see Result#intern(Field...)
     * @see String#intern()
     *
     * @deprecated - 3.10 - [#6254] - This functionality is no longer supported
     *             and will be removed in 4.0
     */
    @NotNull
    @Deprecated
    ResultQuery<R> intern(Field<?>... fields);

    /**
     * Specify a set of field indexes whose values should be interned.
     * <p>
     * Unlike {@link Result}'s <code>intern()</code> methods, this already
     * interns values right after fetching them from a JDBC result set. See
     * {@link Result#intern(int...)} for more details.
     *
     * @param fieldIndexes The field indexes whose values should be interned
     * @return The same result query
     * @see Result#intern(int...)
     * @see String#intern()
     *
     * @deprecated - 3.10 - [#6254] - This functionality is no longer supported
     *             and will be removed in 4.0
     */
    @NotNull
    @Deprecated
    ResultQuery<R> intern(int... fieldIndexes);

    /**
     * Specify a set of field names whose values should be interned.
     * <p>
     * Unlike {@link Result}'s <code>intern()</code> methods, this already
     * interns values right after fetching them from a JDBC result set. See
     * {@link Result#intern(String...)} for more details.
     *
     * @param fieldNames The field names whose values should be interned
     * @return The same result query
     * @see Result#intern(String...)
     * @see String#intern()
     *
     * @deprecated - 3.10 - [#6254] - This functionality is no longer supported
     *             and will be removed in 4.0
     */
    @NotNull
    @Deprecated
    ResultQuery<R> intern(String... fieldNames);

    /**
     * Specify a set of field names whose values should be interned.
     * <p>
     * Unlike {@link Result}'s <code>intern()</code> methods, this already
     * interns values right after fetching them from a JDBC result set. See
     * {@link Result#intern(Name...)} for more details.
     *
     * @param fieldNames The field names whose values should be interned
     * @return The same result query
     * @see Result#intern(Name...)
     * @see String#intern()
     *
     * @deprecated - 3.10 - [#6254] - This functionality is no longer supported
     *             and will be removed in 4.0
     */
    @NotNull
    @Deprecated
    ResultQuery<R> intern(Name... fieldNames);

    /**
     * Coerce the result record type of this query to that of a table.
     */
    @NotNull
    <X extends Record> ResultQuery<X> coerce(Table<X> table);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    ResultQuery<Record> coerce(Field<?>... fields);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    ResultQuery<Record> coerce(Collection<? extends Field<?>> fields);



    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1> ResultQuery<Record1<T1>> coerce(Field<T1> field1);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2> ResultQuery<Record2<T1, T2>> coerce(Field<T1> field1, Field<T2> field2);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3> ResultQuery<Record3<T1, T2, T3>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4> ResultQuery<Record4<T1, T2, T3, T4>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5> ResultQuery<Record5<T1, T2, T3, T4, T5>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6> ResultQuery<Record6<T1, T2, T3, T4, T5, T6>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7> ResultQuery<Record7<T1, T2, T3, T4, T5, T6, T7>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8> ResultQuery<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9> ResultQuery<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ResultQuery<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ResultQuery<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ResultQuery<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ResultQuery<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ResultQuery<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ResultQuery<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ResultQuery<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ResultQuery<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ResultQuery<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ResultQuery<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ResultQuery<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ResultQuery<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21);

    /**
     * Coerce the result record type of this query to that of a set of fields.
     */
    @NotNull
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ResultQuery<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> coerce(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22);



}
